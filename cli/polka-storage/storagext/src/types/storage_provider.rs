/// This module contains trait implementation for storage provider related types.
///
/// Since `storagext` declares some "duplicate" types from the runtime to be more ergonomic,
/// types imported from the runtime that have doppelgangers, should be imported using `as` and
/// prefixed with `Runtime`, making them easily distinguishable from their doppelgangers.
use std::collections::BTreeSet;

use cid::Cid;
use codec::Encode;
use frame_support::CloneNoBound;
use primitives_proofs::{DealId, RegisteredSealProof, SectorNumber};
use subxt::{self, ext::sp_runtime::MultiSignature, tx::Signer, utils::Static};

use crate::{
    runtime::{
        bounded_vec::IntoBoundedByteVec,
        runtime_types::{
            bounded_collections::{bounded_btree_set, bounded_vec},
            pallet_storage_provider::{
                fault::{
                    DeclareFaultsParams as RuntimeDeclareFaultsParams,
                    DeclareFaultsRecoveredParams as RuntimeDeclareFaultsRecoveredParams,
                    FaultDeclaration as RuntimeFaultDeclaration,
                    RecoveryDeclaration as RuntimeRecoveryDeclaration,
                },
                sector::{
                    self, ProveCommitSector as RuntimeProveCommitSector,
                    SectorPreCommitInfo as RuntimeSectorPreCommitInfo,
                },
            },
        },
    },
    BlockNumber,
};

// The following conversions have specific account ID types because of the subxt generation,
// the type required there is `subxt::ext::subxt_core::utils::AccountId32`, however, this type
// is not very useful on its own, it doesn't allow us to print an account ID as anything else
// other than an array of bytes, hence, we use a more generic type for the config
// `subxt::ext::sp_core::crypto::AccountId32` and convert back to the one generated by subxt.

#[derive(Clone, Debug)]
pub struct SectorPreCommitInfo {
    pub seal_proof: RegisteredSealProof,
    pub sector_number: SectorNumber,
    pub sealed_cid: Cid,
    pub deal_ids: Vec<DealId>,
    pub expiration: BlockNumber,
    pub unsealed_cid: Cid,
}

impl From<SectorPreCommitInfo> for RuntimeSectorPreCommitInfo<BlockNumber> {
    fn from(value: SectorPreCommitInfo) -> Self {
        Self {
            seal_proof: value.seal_proof,
            sector_number: value.sector_number,
            sealed_cid: value.sealed_cid.into_bounded_byte_vec(),
            deal_ids: crate::runtime::polka_storage_runtime::runtime_types::bounded_collections::bounded_vec::BoundedVec(value.deal_ids),
            expiration: value.expiration,
            unsealed_cid: value.unsealed_cid.into_bounded_byte_vec(),
        }
    }
}

impl From<RuntimeSectorPreCommitInfo<BlockNumber>> for SectorPreCommitInfo {
    fn from(value: RuntimeSectorPreCommitInfo<BlockNumber>) -> Self {
        Self {
            seal_proof: value.seal_proof,
            sector_number: value.sector_number,
            sealed_cid: Cid::read_bytes(value.sealed_cid.0.as_slice())
                .expect("a proper value to have been stored on chain"),
            deal_ids: value.deal_ids.0,
            expiration: value.expiration,
            unsealed_cid: Cid::read_bytes(value.unsealed_cid.0.as_slice())
                .expect("a proper value to have been stored on chain"),
        }
    }
}

impl PartialEq<RuntimeSectorPreCommitInfo<BlockNumber>> for SectorPreCommitInfo {
    fn eq(&self, other: &RuntimeSectorPreCommitInfo<BlockNumber>) -> bool {
        self.deal_ids == other.deal_ids.0
            && self.expiration == other.expiration
            && self.seal_proof == other.seal_proof
            && self.sealed_cid.to_bytes() == other.sealed_cid.0
            && self.unsealed_cid.to_bytes() == other.unsealed_cid.0
            && self.sector_number == other.sector_number
    }
}

impl PartialEq<SectorPreCommitInfo> for RuntimeSectorPreCommitInfo<BlockNumber> {
    fn eq(&self, other: &SectorPreCommitInfo) -> bool {
        self.deal_ids.0 == other.deal_ids
            && self.expiration == other.expiration
            && self.seal_proof == other.seal_proof
            && self.sealed_cid.0 == other.sealed_cid.to_bytes()
            && self.unsealed_cid.0 == other.unsealed_cid.to_bytes()
            && self.sector_number == other.sector_number
    }
}

#[derive(CloneNoBound)]
pub struct ProveCommitSector {
    pub sector_number: SectorNumber,
    pub proof: Vec<u8>,
}

impl From<ProveCommitSector> for RuntimeProveCommitSector {
    fn from(value: ProveCommitSector) -> Self {
        Self {
            sector_number: value.sector_number,
            proof: value.proof.into_bounded_byte_vec(),
        }
    }
}

#[derive(PartialEq, Eq, Debug, Clone, serde::Deserialize)]
pub struct FaultDeclaration {
    pub deadline: u64,
    pub partition: u32,
    pub sectors: BTreeSet<u64>,
}

impl From<FaultDeclaration> for RuntimeFaultDeclaration {
    fn from(value: FaultDeclaration) -> Self {
        Self {
            deadline: value.deadline,
            partition: value.partition,
            // Converts from BTreeSet -> Vec -> BoundedBTreeSet because subxt...
            sectors: bounded_btree_set::BoundedBTreeSet(value.sectors.into_iter().collect()),
        }
    }
}

impl From<Vec<FaultDeclaration>> for RuntimeDeclareFaultsParams {
    fn from(value: Vec<FaultDeclaration>) -> Self {
        Self {
            faults: bounded_vec::BoundedVec(value.into_iter().map(Into::into).collect()),
        }
    }
}

impl PartialEq<FaultDeclaration> for RuntimeFaultDeclaration {
    fn eq(&self, other: &FaultDeclaration) -> bool {
        self.deadline == other.deadline
            && self.partition == other.partition
            && self.sectors.0.len() == other.sectors.len()
            && self
                .sectors
                .0
                .iter()
                .all(|sector| other.sectors.contains(sector))
    }
}

impl PartialEq<RuntimeFaultDeclaration> for FaultDeclaration {
    fn eq(&self, other: &RuntimeFaultDeclaration) -> bool {
        self.deadline == other.deadline
            && self.partition == other.partition
            && self.sectors.len() == other.sectors.0.len()
            && other
                .sectors
                .0
                .iter()
                .all(|sector| self.sectors.contains(sector))
    }
}

#[derive(PartialEq, Eq, Debug, Clone, serde::Deserialize)]
pub struct RecoveryDeclaration {
    pub deadline: u64,
    pub partition: u32,
    pub sectors: BTreeSet<u64>,
}

impl From<RecoveryDeclaration> for RuntimeRecoveryDeclaration {
    fn from(value: RecoveryDeclaration) -> Self {
        Self {
            deadline: value.deadline,
            partition: value.partition,
            // Converts from BTreeSet -> Vec -> BoundedBTreeSet because subxt...
            sectors: bounded_btree_set::BoundedBTreeSet(value.sectors.into_iter().collect()),
        }
    }
}

impl From<Vec<RecoveryDeclaration>> for RuntimeDeclareFaultsRecoveredParams {
    fn from(value: Vec<RecoveryDeclaration>) -> Self {
        Self {
            recoveries: bounded_vec::BoundedVec(value.into_iter().map(Into::into).collect()),
        }
    }
}

impl PartialEq<RecoveryDeclaration> for RuntimeRecoveryDeclaration {
    fn eq(&self, other: &RecoveryDeclaration) -> bool {
        self.deadline == other.deadline
            && self.partition == other.partition
            && self.sectors.0.len() == other.sectors.len()
            && self
                .sectors
                .0
                .iter()
                .all(|sector| other.sectors.contains(sector))
    }
}

impl PartialEq<RuntimeRecoveryDeclaration> for RecoveryDeclaration {
    fn eq(&self, other: &RuntimeRecoveryDeclaration) -> bool {
        self.deadline == other.deadline
            && self.partition == other.partition
            && self.sectors.len() == other.sectors.0.len()
            && other
                .sectors
                .0
                .iter()
                .all(|sector| self.sectors.contains(sector))
    }
}

#[cfg(test)]
mod tests {
    use std::collections::BTreeSet;

    use crate::{FaultDeclaration, RecoveryDeclaration};

    #[test]
    fn ensure_deserialization_faults() {
        let declaration = r#"
        {
            "deadline": 0,
            "partition": 0,
            "sectors": [0, 1]
        }
        "#;
        let result: FaultDeclaration = serde_json::from_str(declaration).unwrap();
        let expected = FaultDeclaration {
            deadline: 0,
            partition: 0,
            sectors: BTreeSet::from_iter([0, 1].into_iter()),
        };
        assert_eq!(expected, result);
    }

    #[test]
    fn ensure_deserialization_faults_vec() {
        let declaration = r#"
        [{
            "deadline": 0,
            "partition": 0,
            "sectors": [0, 1]
        }]
        "#;
        let result: Vec<FaultDeclaration> = serde_json::from_str(declaration).unwrap();
        let expected = vec![FaultDeclaration {
            deadline: 0,
            partition: 0,
            sectors: BTreeSet::from_iter([0, 1].into_iter()),
        }];
        assert_eq!(expected, result);
    }

    #[test]
    fn ensure_deserialization_recoveries() {
        let declaration = r#"
        {
            "deadline": 0,
            "partition": 0,
            "sectors": [0, 1]
        }
        "#;
        let result: RecoveryDeclaration = serde_json::from_str(declaration).unwrap();
        let expected = RecoveryDeclaration {
            deadline: 0,
            partition: 0,
            sectors: BTreeSet::from_iter([0, 1].into_iter()),
        };
        assert_eq!(expected, result);
    }

    #[test]
    fn ensure_deserialization_recoveries_vec() {
        let declaration = r#"
        [{
            "deadline": 0,
            "partition": 0,
            "sectors": [0, 1]
        }]
        "#;
        let result: Vec<RecoveryDeclaration> = serde_json::from_str(declaration).unwrap();
        let expected = vec![RecoveryDeclaration {
            deadline: 0,
            partition: 0,
            sectors: BTreeSet::from_iter([0, 1].into_iter()),
        }];
        assert_eq!(expected, result);
    }
}
